pub mod build;
pub mod container;
mod globals;
pub mod image;
mod install;
pub mod kube;
mod network;
mod pod;
mod service;
mod unit;
mod volume;

use std::{
    collections::HashSet,
    fmt::{self, Display, Formatter},
    iter,
    path::PathBuf,
    str::FromStr,
};

use clap::ValueEnum;
use compose_spec::service::build::Context;
use serde::{Serialize, Serializer, ser::SerializeSeq};
use smart_default::SmartDefault;
use thiserror::Error;

pub use self::{
    build::Build,
    container::Container,
    globals::Globals,
    image::Image,
    install::Install,
    kube::Kube,
    network::{IpRange, Network},
    pod::Pod,
    service::Service,
    unit::Unit,
    volume::Volume,
};
use crate::serde::skip_true;

/// Generic Quadlet sections able to be used by all Quadlet types.
///
/// Commonly grouped together when creating Quadlet [`File`]s.
#[derive(Debug, Clone, PartialEq)]
pub struct GenericSections {
    /// The `[Unit]` section.
    pub unit: Unit,
    /// The `[Quadlet]` section.
    pub quadlet: Quadlet,
    /// The `[Install]` section.
    pub install: Install,
}

#[derive(Debug, Clone, PartialEq)]
pub struct File {
    pub name: String,
    pub unit: Unit,
    pub resource: Resource,
    pub globals: Globals,
    pub quadlet: Quadlet,
    pub service: Service,
    pub install: Install,
}

impl File {
    /// Returns the corresponding service file name generated by Quadlet.
    pub fn service_name(&self) -> String {
        self.resource.name_to_service(&self.name)
    }

    /// Serialize this Quadlet [`File`] to the Quadlet file format.
    ///
    /// Quadlet options in `join_options` are joined together with a space.
    ///
    /// # Errors
    ///
    /// Returns an error if any of the contained values return an error while serializing.
    pub fn serialize_to_quadlet(
        &self,
        join_options: &HashSet<JoinOption>,
    ) -> Result<String, crate::serde::quadlet::Error> {
        crate::serde::quadlet::to_string(self, join_options)
    }

    /// If this Quadlet [`File`] is a [`Container`] unit, set the `StartWithPod=` Quadlet option.
    pub fn set_start_with_pod(&mut self, start_with_pod: bool) {
        if let Resource::Container(container) = &mut self.resource {
            container.start_with_pod = start_with_pod;
        }
    }
}

impl Serialize for File {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        let Self {
            name: _,
            unit,
            resource,
            globals,
            quadlet,
            service,
            install,
        } = self;

        let len = usize::from(!unit.is_empty())
            + 1 // resource / globals
            + usize::from(!quadlet.is_empty())
            + usize::from(!service.is_empty())
            + usize::from(!install.is_empty());

        let mut seq = serializer.serialize_seq(Some(len))?;

        if !unit.is_empty() {
            seq.serialize_element(unit)?;
        }

        seq.serialize_element(&(resource, globals))?;

        if !quadlet.is_empty() {
            seq.serialize_element(quadlet)?;
        }

        if !service.is_empty() {
            seq.serialize_element(service)?;
        }

        if !install.is_empty() {
            seq.serialize_element(install)?;
        }

        seq.end()
    }
}

impl HostPaths for File {
    fn host_paths(&mut self) -> impl Iterator<Item = &mut PathBuf> {
        self.resource.host_paths().chain(self.globals.host_paths())
    }
}

impl Downgrade for File {
    fn downgrade(&mut self, version: PodmanVersion) -> Result<(), DowngradeError> {
        let Self {
            name: _,
            unit: _,
            resource,
            globals,
            quadlet,
            service: _,
            install: _,
        } = self;

        resource.downgrade(version)?;
        globals.downgrade(version)?;
        quadlet.downgrade(version)?;

        Ok(())
    }
}

/// Quadlet options that may be joined together in a space separated list.
#[derive(ValueEnum, Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[value(rename_all = "PascalCase")]
pub enum JoinOption {
    /// `AddCapability=`, used in [Container] sections.
    AddCapability,

    /// `After=`, used in [Unit] sections.
    After,

    /// `Annotation=`, used in [Container] and [Build] sections.
    Annotation,

    /// `Before=`, used in [Unit] sections.
    Before,

    /// `BindsTo=`, used in [Unit] sections.
    BindsTo,

    /// `DropCapability=`, used in [Container] sections.
    DropCapability,

    /// `Environment=`, used in [Container] and [Build] sections.
    Environment,

    /// `Label=`, used in [Container], [Network], [Volume], and [Build] sections.
    Label,

    /// `Mask=`, used in [Container] sections.
    Mask,

    /// `PartOf=`, used in [Unit] sections.
    PartOf,

    /// `RequiredBy=`, used in [Install] sections.
    RequiredBy,

    /// `Requires=`, used in [Unit] sections.
    Requires,

    /// `Sysctl=`, used in [Container] sections.
    Sysctl,

    /// `Unmask=`, used in [Container] sections.
    Unmask,

    /// `WantedBy=`, used in [Install] sections.
    WantedBy,

    /// `Wants=`, used in [Unit] sections.
    Wants,
}

impl JoinOption {
    /// A static slice of all variants of [`JoinOption`].
    pub const ALL: &'static [Self] = &[
        Self::AddCapability,
        Self::After,
        Self::Annotation,
        Self::Before,
        Self::BindsTo,
        Self::DropCapability,
        Self::Environment,
        Self::Label,
        Self::Mask,
        Self::PartOf,
        Self::RequiredBy,
        Self::Requires,
        Self::Sysctl,
        Self::Unmask,
        Self::WantedBy,
        Self::Wants,
    ];

    /// Create a [`HashSet`] containing all variants of [`JoinOption`].
    pub fn all_set() -> HashSet<Self> {
        Self::ALL.iter().copied().collect()
    }

    /// Join option as a static string slice.
    pub const fn as_str(self) -> &'static str {
        match self {
            Self::AddCapability => "AddCapability",
            Self::After => "After",
            Self::Annotation => "Annotation",
            Self::Before => "Before",
            Self::BindsTo => "BindsTo",
            Self::DropCapability => "DropCapability",
            Self::Environment => "Environment",
            Self::Label => "Label",
            Self::Mask => "Mask",
            Self::PartOf => "PartOf",
            Self::RequiredBy => "RequiredBy",
            Self::Requires => "Requires",
            Self::Sysctl => "Sysctl",
            Self::Unmask => "Unmask",
            Self::WantedBy => "WantedBy",
            Self::Wants => "Wants",
        }
    }
}

impl Display for JoinOption {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        f.write_str(self.as_str())
    }
}

impl FromStr for JoinOption {
    type Err = ParseJoinOptionError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "AddCapability" => Ok(Self::AddCapability),
            "After" => Ok(Self::After),
            "Annotation" => Ok(Self::Annotation),
            "Before" => Ok(Self::Before),
            "BindsTo" => Ok(Self::BindsTo),
            "DropCapability" => Ok(Self::DropCapability),
            "Environment" => Ok(Self::Environment),
            "Label" => Ok(Self::Label),
            "Mask" => Ok(Self::Mask),
            "PartOf" => Ok(Self::PartOf),
            "RequiredBy" => Ok(Self::RequiredBy),
            "Requires" => Ok(Self::Requires),
            "Sysctl" => Ok(Self::Sysctl),
            "Unmask" => Ok(Self::Unmask),
            "WantedBy" => Ok(Self::WantedBy),
            "Wants" => Ok(Self::Wants),
            s => Err(ParseJoinOptionError(s.to_owned())),
        }
    }
}

/// Error returned when attempting to parse an invalid [`JoinOption`] variant.
#[derive(Debug, Error)]
#[error("`{0}` is either not a valid Quadlet option or the option cannot be joined together")]
pub struct ParseJoinOptionError(String);

#[derive(Serialize, Debug, Clone, PartialEq)]
#[serde(untagged)]
pub enum Resource {
    Container(Box<Container>),
    Pod(Pod),
    Kube(Kube),
    Network(Network),
    Volume(Volume),
    Build(Box<Build>),
    Image(Image),
}

impl From<Container> for Resource {
    fn from(value: Container) -> Self {
        Self::Container(Box::new(value))
    }
}

impl From<Box<Container>> for Resource {
    fn from(value: Box<Container>) -> Self {
        Self::Container(value)
    }
}

impl From<Pod> for Resource {
    fn from(value: Pod) -> Self {
        Self::Pod(value)
    }
}

impl From<Kube> for Resource {
    fn from(value: Kube) -> Self {
        Self::Kube(value)
    }
}

impl From<Network> for Resource {
    fn from(value: Network) -> Self {
        Self::Network(value)
    }
}

impl From<Volume> for Resource {
    fn from(value: Volume) -> Self {
        Self::Volume(value)
    }
}

impl From<Build> for Resource {
    fn from(value: Build) -> Self {
        Self::Build(Box::new(value))
    }
}

impl From<Box<Build>> for Resource {
    fn from(value: Box<Build>) -> Self {
        Self::Build(value)
    }
}

impl From<Image> for Resource {
    fn from(value: Image) -> Self {
        Self::Image(value)
    }
}

impl Resource {
    /// The extension that should be used for the generated file.
    pub fn extension(&self) -> &'static str {
        ResourceKind::from(self).as_str()
    }

    /// Takes a file name (no extension) and returns the corresponding service file name
    /// generated by Quadlet.
    pub fn name_to_service(&self, name: &str) -> String {
        let mut service = match self {
            Self::Container(_) | Self::Kube(_) => String::from(name),
            Self::Pod(_) => format!("{name}-pod"),
            Self::Network(_) => format!("{name}-network"),
            Self::Volume(_) => format!("{name}-volume"),
            Self::Build(_) => format!("{name}-build"),
            Self::Image(_) => format!("{name}-image"),
        };
        service.push_str(".service");
        service
    }
}

impl HostPaths for Resource {
    fn host_paths(&mut self) -> impl Iterator<Item = &mut PathBuf> {
        match self {
            Self::Container(container) => ResourceIter::Container(container.host_paths()),
            Self::Pod(pod) => ResourceIter::Pod(pod.host_paths()),
            Self::Kube(kube) => ResourceIter::Kube(kube.host_paths()),
            Self::Network(_) => ResourceIter::Network(iter::empty()),
            Self::Volume(volume) => ResourceIter::Volume(volume.host_paths()),
            Self::Build(build) => ResourceIter::Build(build.host_paths()),
            Self::Image(image) => ResourceIter::Image(image.host_paths()),
        }
    }
}

/// [`Iterator`] for all [`Resource`] types.
enum ResourceIter<C, P, K, N, V, B, I> {
    Container(C),
    Pod(P),
    Kube(K),
    Network(N),
    Volume(V),
    Build(B),
    Image(I),
}

impl<C, P, K, N, V, B, I, Item> Iterator for ResourceIter<C, P, K, N, V, B, I>
where
    C: Iterator<Item = Item>,
    P: Iterator<Item = Item>,
    K: Iterator<Item = Item>,
    N: Iterator<Item = Item>,
    V: Iterator<Item = Item>,
    B: Iterator<Item = Item>,
    I: Iterator<Item = Item>,
{
    type Item = Item;

    fn next(&mut self) -> Option<Self::Item> {
        match self {
            Self::Container(iter) => iter.next(),
            Self::Pod(iter) => iter.next(),
            Self::Kube(iter) => iter.next(),
            Self::Network(iter) => iter.next(),
            Self::Volume(iter) => iter.next(),
            Self::Build(iter) => iter.next(),
            Self::Image(iter) => iter.next(),
        }
    }
}

impl Downgrade for Resource {
    fn downgrade(&mut self, version: PodmanVersion) -> Result<(), DowngradeError> {
        match self {
            Self::Container(container) => container.downgrade(version),
            Self::Pod(pod) => pod.downgrade(version),
            Self::Kube(kube) => kube.downgrade(version),
            Self::Network(network) => network.downgrade(version),
            Self::Volume(volume) => volume.downgrade(version),
            Self::Build(build) => build.downgrade(version),
            Self::Image(image) => image.downgrade(version),
        }
    }
}

/// Quadlet [`Resource`] kinds
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ResourceKind {
    Container,
    Pod,
    Kube,
    Network,
    Volume,
    Build,
    Image,
}

impl ResourceKind {
    /// Resource kind as a lowercase static string slice.
    pub const fn as_str(self) -> &'static str {
        match self {
            Self::Container => "container",
            Self::Pod => "pod",
            Self::Kube => "kube",
            Self::Network => "network",
            Self::Volume => "volume",
            Self::Build => "build",
            Self::Image => "image",
        }
    }
}

impl Display for ResourceKind {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        f.write_str(self.as_str())
    }
}

impl From<&Resource> for ResourceKind {
    fn from(value: &Resource) -> Self {
        match value {
            Resource::Container(_) => Self::Container,
            Resource::Pod(_) => Self::Pod,
            Resource::Kube(_) => Self::Kube,
            Resource::Network(_) => Self::Network,
            Resource::Volume(_) => Self::Volume,
            Resource::Build(_) => Self::Build,
            Resource::Image(_) => Self::Image,
        }
    }
}

/// The `[Quadlet]` section.
///
/// Options shared between all unit types.
#[derive(Serialize, SmartDefault, Debug, Clone, Copy, PartialEq)]
#[serde(rename_all = "PascalCase")]
pub struct Quadlet {
    /// Whether to add Quadlet's default network dependencies to the unit (default is `true`).
    ///
    /// When set to false, Quadlet will **not** add a dependency (After=, Wants=) to
    /// `network-online.target/podman-user-wait-network-online.service` to the generated unit.
    #[serde(skip_serializing_if = "skip_true")]
    #[default = true]
    pub default_dependencies: bool,
}

impl Quadlet {
    /// Returns `true` if all fields are set to their default value.
    pub fn is_empty(self) -> bool {
        let Self {
            default_dependencies,
        } = self;

        default_dependencies
    }
}

impl Downgrade for Quadlet {
    fn downgrade(&mut self, version: PodmanVersion) -> Result<(), DowngradeError> {
        if version < PodmanVersion::V5_3 && !self.default_dependencies {
            return Err(DowngradeError::Option {
                quadlet_option: "DefaultDependencies",
                value: "false".to_owned(),
                supported_version: PodmanVersion::V5_3,
            });
        }

        Ok(())
    }
}

/// Trait for types which have varying levels of compatibility with different [`PodmanVersion`]s.
pub trait Downgrade {
    /// Downgrade Podman compatibility to `version`.
    ///
    /// This is a one-way transformation, calling downgrade a second time with a higher version
    /// will not increase the Quadlet options used.
    ///
    /// # Errors
    ///
    /// Returns an error if the given [`PodmanVersion`] does not support a used Quadlet option or
    /// the type of Quadlet file.
    fn downgrade(&mut self, version: PodmanVersion) -> Result<(), DowngradeError>;
}

/// Versions of Podman since Quadlet was added.
///
/// Each version added new features to Quadlet.
#[non_exhaustive]
#[derive(ValueEnum, Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum PodmanVersion {
    /// Podman v4.4
    #[value(name = "4.4", aliases = ["4.4.0", "4.4.1", "4.4.2", "4.4.3", "4.4.4"])]
    V4_4,

    /// Podman v4.5
    #[value(name = "4.5", aliases = ["4.5.0", "4.5.1"])]
    V4_5,

    /// Podman v4.6
    #[value(name = "4.6", aliases = ["4.6.0", "4.6.1", "4.6.2"])]
    V4_6,

    /// Podman v4.7
    #[value(name = "4.7", aliases = ["4.7.0", "4.7.1", "4.7.2"])]
    V4_7,

    /// Podman v4.8 and v4.9
    #[value(
        name = "4.8",
        aliases = ["4.8.0", "4.8.1", "4.8.2", "4.8.3", "4.9", "4.9.0", "4.9.1", "4.9.2", "4.9.3", "4.9.4", "4.9.5"]
    )]
    V4_8,

    /// Podman v5.0
    #[value(name = "5.0", aliases = ["5.0.0", "5.0.1", "5.0.2", "5.0.3"])]
    V5_0,

    /// Podman v5.1
    #[value(name = "5.1", aliases = ["5.1.0", "5.1.1", "5.1.2"])]
    V5_1,

    /// Podman v5.2
    #[value(name = "5.2", aliases = ["5.2.0", "5.2.1", "5.2.2", "5.2.3", "5.2.4", "5.2.5"])]
    V5_2,

    /// Podman v5.3
    #[value(name = "5.3", aliases = ["latest", "5.3.0", "5.3.1", "5.3.2"])]
    V5_3,
}

impl PodmanVersion {
    /// Latest supported version of Podman with regards to Quadlet.
    pub const LATEST: Self = Self::V5_3;

    /// Podman version as a static string slice.
    pub const fn as_str(self) -> &'static str {
        match self {
            Self::V4_4 => "4.4",
            Self::V4_5 => "4.5",
            Self::V4_6 => "4.6",
            Self::V4_7 => "4.7",
            Self::V4_8 => "4.8",
            Self::V5_0 => "5.0",
            Self::V5_1 => "5.1",
            Self::V5_2 => "5.2",
            Self::V5_3 => "5.3",
        }
    }
}

impl Default for PodmanVersion {
    fn default() -> Self {
        Self::LATEST
    }
}

impl Display for PodmanVersion {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        f.write_str(self.as_str())
    }
}

/// Error returned when [downgrading](Downgrade::downgrade()) a Quadlet file fails.
#[derive(Error, Debug)]
pub enum DowngradeError {
    /// Unsupported Quadlet option used.
    #[error(
        "Quadlet option `{quadlet_option}={value}` was not \
        supported until Podman v{supported_version}"
    )]
    Option {
        quadlet_option: &'static str,
        value: String,
        supported_version: PodmanVersion,
    },

    /// Quadlet option set multiple times before supported.
    #[error(
        "Quadlet option `{quadlet_option}=` could not be set multiple \
        times until Podman v{supported_version}"
    )]
    Multiple {
        quadlet_option: &'static str,
        supported_version: PodmanVersion,
    },

    /// Unsupported Quadlet kind.
    #[error("`.{kind}` Quadlet files were not supported until Podman v{supported_version}")]
    Kind {
        kind: ResourceKind,
        supported_version: PodmanVersion,
    },
}

/// Valid values for the `AutoUpdate=` Quadlet option.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AutoUpdate {
    Registry,
    Local,
}

impl AutoUpdate {
    /// Podman-specific label for `podman auto-update`.
    ///
    /// See <https://docs.podman.io/en/stable/markdown/podman-auto-update.1.html>
    const LABEL_KEY: &'static str = "io.containers.autoupdate";

    /// Extracts all valid values of the `io.containers.autoupdate` label from `labels`,
    /// the last value of which is parsed into an [`AutoUpdate`].
    ///
    /// Returns `None` if no valid `io.containers.autoupdate` label is found.
    ///
    /// `io.containers.autoupdate` labels with invalid values are retained in `labels`.
    pub fn extract_from_labels(labels: &mut Vec<String>) -> Option<Self> {
        let mut auto_update = None;
        labels.retain(|label| {
            label
                .strip_prefix(Self::LABEL_KEY)
                .and_then(|label| label.strip_prefix('='))
                .and_then(|value| value.parse().ok())
                .is_none_or(|value| {
                    auto_update = Some(value);
                    false
                })
        });

        auto_update
    }
}

impl AsRef<str> for AutoUpdate {
    fn as_ref(&self) -> &str {
        match self {
            Self::Registry => "registry",
            Self::Local => "local",
        }
    }
}

impl Display for AutoUpdate {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        f.write_str(self.as_ref())
    }
}

impl Serialize for AutoUpdate {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        serializer.serialize_str(self.as_ref())
    }
}

impl FromStr for AutoUpdate {
    type Err = ParseAutoUpdateError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "registry" => Ok(Self::Registry),
            "local" => Ok(Self::Local),
            s => Err(ParseAutoUpdateError(s.into())),
        }
    }
}

/// Error returned when attempting to parse an invalid [`AutoUpdate`] variant,
/// see [`AutoUpdate::from_str()`].
#[derive(Debug, Error)]
#[error("unknown auto update variant `{0}`, must be `registry` or `local`")]
pub struct ParseAutoUpdateError(String);

/// Trait for types which contain paths on the host.
pub trait HostPaths {
    /// Retrieve an [`Iterator`] over mutable references to all [`PathBuf`]s that represent paths
    /// on the host.
    fn host_paths(&mut self) -> impl Iterator<Item = &mut PathBuf>;
}

impl<T: HostPaths> HostPaths for &mut T {
    fn host_paths(&mut self) -> impl Iterator<Item = &mut PathBuf> {
        T::host_paths(self)
    }
}

impl<T: HostPaths> HostPaths for Vec<T> {
    fn host_paths(&mut self) -> impl Iterator<Item = &mut PathBuf> {
        self.iter_mut().flat_map(T::host_paths)
    }
}

impl<T: HostPaths> HostPaths for Option<T> {
    fn host_paths(&mut self) -> impl Iterator<Item = &mut PathBuf> {
        self.iter_mut().flat_map(T::host_paths)
    }
}

impl HostPaths for Context {
    fn host_paths(&mut self) -> impl Iterator<Item = &mut PathBuf> {
        match self {
            Self::Path(path) => Some(path),
            Self::Url(_) => None,
        }
        .into_iter()
    }
}
